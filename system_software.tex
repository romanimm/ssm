\chapter{System-Software}

\section{System-Struktur}
Die System-Struktur ist auf der Abbildung \ref{fig:system-software-system-struktur} ersichtlich. Das Dateisystem ist für gewöhnlich hierarchisch gegliedert. Speziell: Auf Linux-Systemen werden Peripherie-Geräte als Files behandelt, unter /dev für device.

\begin{figure}[h!]
	\centering
	\begin{subfigure}[b]{0.4\textwidth}
	       	\includegraphics[width=\textwidth]{fig/system-software-system-struktur}
	       	\caption{System-Struktur}
	       	\label{fig:system-software-system-struktur}
	\end{subfigure}
	~
	\begin{subfigure}[b]{0.5\textwidth}
		\includegraphics[width=\textwidth]{fig/system-software-systemkern}
		\caption{System-Struktur}
		\label{fig:system-software-systemkern}
	\end{subfigure}
\end{figure}

\subsection{Interrupt-Prioriäten}
\begin{enumerate}
	\item Maschinenfehler (höchste)
	\item Zeitgeber
	\item Disk
	\item Netzwerk
	\item Terminals
	\item Software-Interrupts (niedrigste)
\end{enumerate}

\subsection{Prozess-Elemente}
Ein Prozess kann einzigartig identifiziert werden durch: Identifier (PID), State, Priority, Program Counter, Memory Pointers, Context data, I/O Status infos, accounting infos. Ein Programm ist eine ausführbare Datei. Ein Prozess ist ein in Ausführung befindendes Programm.

\paragraph{Prozess-Kontrol-Block} Enthält die oben genanten Prozess-Elemente. Wenn man alle Elemente eines Prozess hat, kann man diesen quasi schlafen legen (unterbrechen) und später wieder ausführen. Für den Prozess selber ist es so, als wäre er nie unterbrochen worden. Erzeugt und verwaltet durch das OS.

\paragraph{Prozess-Status}
\begin{description}
	\item[Trace (verfolgt):] Zeichnet die Instruktionen eines Prozess auf und kann in aufgrund dessen charakterisieren.
	\item[Dispatcher (verteilt):] Kleines Programm, welches die Prozesse auf dem Prozessor wechselt. Der Scheduler entscheidet welcher Prozess der nächste ist und der Dispatcher entzieht dann dem aktuellen Prozess die CPU und übergibt sie an den nächsten Prozess.
\end{description}

\paragraph{Queuing Modell} Das OS arbeitet intern mit Queues um die Prozesse zu verwalten. Die unterschiedlichen Prozess Status sind als Queues implementiert (Ready-Queue, Blocked-Queue, usw.). Und sobald wieder einer an den Prozessor darf, kann er aus der Ready-Queue genommen werden. Muss der Prozess auf ein Event warten wird er in eine separate Event-Queue verschoben. Tritt das Event dann auf wird er von der Event-Queue in die Ready-Queue verschoben.

\paragraph{OS Control Tables} Für die einzelnen Ressourcen werden Tabellen unterhalten, wie Memory Tables, I/O Tables, File Tables, Prozess Tables.

\paragraph{Process Control Structures}
Um einen Prozess zu verwalten, muss das OS folgendes wissen:
\begin{description}
	\item[Prozess Location] Ein oder mehrere Programme zum Ausführen. Genug Memory um Programm und dessen Daten zu halten. Einen Stack!
	\item[Prozess Attributes] Als \emph{Prozess Image} (Abbildung \ref{fig:system-software-prozess-image}) wird die Sammlung der Programme, Daten, Stack und Attributen bezeichnet. Jeder Prozess hat zudem diverse Attribute, welche sich pro OS unterscheiden können.
\end{description}

\begin{figure}[h!]
\centering
\includegraphics[width=0.2\linewidth]{fig/system-software-prozess-image}
\caption{Prozess-Image}
\label{fig:system-software-prozess-image}
\end{figure}

\paragraph{Virtueller zur physikalischem Adress-Übersetzung}
Wird mittels MMU (Memory Management Unit) gelöst. Mappt physical pages to virtual pages. \\

\subsubsection{Wechsel von Prozess Status}
Ein Prozessor wechselt in einen anderen Status (z.B. bei Interrupt von Running in Ready). Abbildung \ref{fig:system-software-prozess-wechsel} zeigt diesen Statuswechsel.

\begin{figure}[h!]
\centering
\includegraphics[width=0.7\linewidth]{fig/system-software-prozess-wechsel}
\caption{Prozess-Wechsel Vorgang}
\label{fig:system-software-prozess-wechsel}
\end{figure}

\subsubsection{UNIX Process Status}
In UNIX gibt es folgende Prozess Status (MEP):
\begin{description}
	\item[User Running] Ausführung im User Mode.
	\item[Kernel Running] Ausführung im Kernel Mode.
	\item[Ready to Run, in Memory] Bereit zur Ausführung, sobald von Scheduler ausgewählt.
	\item[Asleep in Memory] Prozess blockiert bis ein Event auftritt (blocked).
	\item[Ready to Run, Swapped] Der Prozess ist bereit, aber der Swapper muss den Prozess vor der Ausführung vom Swap in den Hauptspeicher laden.
	\item[Sleeping, Swapped] Prozess blockiert bis ein Event auftritt befindet sich aber im Swap.
	\item[Preempted] Der Prozess möchte gerade vom Kernel in den User Mode wechseln, wird aber vom Kernel verdrängt damit dieser einen anderen Prozess abarbeiten kann.
	\item[Created] Prozess wird erzeugt aber ist noch nicht lauffähig.
	\item[Zombie] Prozess existiert nicht mehr, hinterlässt aber eine Spur für seine Eltern-Prozesse.
\end{description}
Wenn im Hauptspeicher zu wenig Platz ist wird ein Prozess ins Swap ausgelagert. Der Swap wird vom Kernel in der Harddisk erzeugt. Abbildung \ref{fig:system-software-state-engine-processes-unix} zeigt die Übergänge der Prozess Status.

\begin{figure}[h!]
\centering
\includegraphics[width=0.9\linewidth]{fig/system-software-state-engine-processes-unix}
\caption{State Engine Processes in UNIX}
\label{fig:system-software-state-engine-processes-unix}
\end{figure}


\section{Prozess erzeugen}
Prozess wird mittels Kernel system call \texttt{fork()} erzeugt. Anschliessend werden folgende Schritte durchgegangen:
\begin{enumerate}
	\item Freien Platz in der Prozesstabelle reservieren
	\item PID für den Prozess vergeben (der neue Prozess ist zwangsweise ein Child-Prozess)
	\item Kopiere Parent-Prozess Image mit Ausnahme des ''gesharten'' Memory
	\item Zähler für die Files inkrementieren. Um aufzuzeigen, dass ein zusätzlicher Prozess nun auf die Files zugreift.
	\item Prozess in ready-to-run Queue einfügen
	\item PID vom Child-Prozess zum Parent-Prozess übergeben (return value of \texttt{fork()}). Der Child-Prozess bekommt den Wert 0.
\end{enumerate}
Nachdem der Prozess erzeugt ist, ist er wie jeder andere Prozess. Kann also auch dispatched werden.

\section{Unterbrechung von Prozessen}
Es gibt diverse Varianten um Prozesse während der Ausführung zu unterbrechen:
\begin{description}
	\item[Interrupt] Externes Event tritt ein, bei der Ausführung einer Instruktion. Damit können asynchrone Events abgehandelt werden.
	\item[Trap] Verknüpft mit der Ausführung der aktuellen Instruktion. Behandlung eines Fehlers oder einer Ausnahme.
	\item[Supervisor call] Expliziter Request. Aufruf einer OS-Funktion.
\end{description}
Speziell zu erwähnen ist, dass wir zwischen Benutzer-Stack (user) und System-Stack (kernel) unterscheiden.

\subsection{System-Calls}
System-Calls sind die Schnittstelle zwischen dem Betriebssystem und dem Benutzerprogramm. Wir stellen uns eine Single-Core Maschine vor. Der aktuelle Prozess arbeitet gerade im Benutzermodus. Nun will er einen Systemaufruf (lesen einer Datei) machen. Dazu muss eine Unterbrechung oder eine spezielle Systemaufruf-Anweisung durchführen. Dadurch wird die Kontrolle an das BS übergeben. Der Kern führt den Systemcall aus und gibt nach Abschluss die Kontrolle wieder an den User Prozess zurück. Ein Systemcall ist wie eine gewöhnliche Prozedur, jedoch können nur Systemcalls in den Kern eintreten, gewöhnliche nicht.

In der Abbildung \ref{fig:system-software-ablauf-c-read} wird ein Trap ausgeführt in Schritt 6. Da wechselt das Programm vom Benutzermodus in den Kernelmodus. Im Schritt 9 wird kein Trap mehr durchgeführt, das zurückspringen passiert wie bei einer normalen Funktion.

Der Systemcall kann den Aufrufer auch weiterhin blockieren. Wenn das Anwenderprogramm nämlich Input von der Tastatur möchte (mittels Systemcall) und nichts kommt, dann blockiert das BS und lässt andere Prozesse arbeiten.

\begin{figure}[h!]
\centering
\includegraphics[width=0.6\linewidth]{fig/system-software-ablauf-c-read}
\caption{System-Call am Beispiel von C read}
\label{fig:system-software-ablauf-c-read}
\end{figure}

\section{Prozess-Kontext}
Wir unterscheiden zwischen drei Bereichen:
\begin{description}
	\item[Benutzer Kontext] Zugewiesener Adressraum und Daten.
	\item[Hardware Kontext] Multitasking relevant. Inhalte der CPU Register, Seitentabellen etc.
	\item[System Kontext] OS Sicht. PID, geöffnete Dateien, Info Eltern und Kind Prozesse, Prioritäten etc. 
\end{description}

\paragraph{File-Deskriptoren}
Jedes geöffnete File erhält eine ID. Jeder Prozess hat seine eigene File Deskriptoren Tabelle, welche eine Sammlung von Pointer ist zu den I/O Streams.

Standardmässig gibt es folgende Streams: \texttt{stdin} (z.B. Keyboard), \texttt{stdout} (z.B. Display) und \texttt{stderr} (z.B. Fehlermeldung auf Display).

Diese Standard-Kanäle können umgebogen werden. Mittels \texttt{>} oder \texttt{|}

\section{Threads}
Die Idee kennen wir. Leichtgewichtige Threads vs. schwergewichtige Prozesse. Unter einem einzigen Prozess können mehrere Threads laufen. Im Gegensatz zu Prozessen ist die Erzeugung, Beendigung und Wechsel zwischen Threads um einiges schneller. Auch die Kommunikation ist auf natürlich weise mit dem gemeinsamen Prozess Kontext gegeben.

\begin{figure}[h!]
\centering
\includegraphics[width=0.7\linewidth]{fig/system-software-single-threaded-vs-muli-threaded}
\caption{Single Threaded vs. Multi-Threaded}
\label{fig:system-software-single-threaded-vs-muli-threaded}
\end{figure}

\subsection{Thread-Kontext}
Ein Prozess besteht aus mind. 1 Thread. Threads vom gleichen Prozess teilen sich Codesegmente, Datensegmente und Dateideskriptoren. Jeder Thread hat seinen Stack (User und Kernel Stack) und seinen Code Pointer.

\subsection{Thread-Arten}
\begin{description}
	\item[User Level Threads (ULT)]
	Thread Mgmt. in der Applikation. Der Kern hat keine Kenntnis über die Existenz von Threads. Arbeiten komplett im User Space. Müssen Kontrolle von sich aus abgegeben. Neigen mehr zu kooperativem als zu preemptiven Scheduling. Implementieren manchmal das Scheduling selber (z.B. frühere Versionen von Java.).
	Dafür gibt es ein paar Vorteile: Thread Wechsel verlangt keinen Kernel Modus, Scheduling applikationspezifisch (Programmierer kann beeinflussen), ULTs laufen auf jedem OS.
	\item[Kernel Level Threads (KLT)]
	Thread Mgmt. vom Kern. Windows verfolgt diesen Ansatz. Der Kern kann mehrere Threads vom gleichen Prozess auf mehrere Prozessoren verteilen (Scheduling). Wenn ein Thread blockiert ist, kann ein Thread vom gleichen Prozess berücksichtigt werden. Kern Prozeduren können multithreaded ausgeführt werden.
\end{description}

\subsection{Kombinierter Ansatz}
Oft kommt wohl eine Kombination zum Zug. Thread Erzeugung und generelles Thread Management wird von der Applikation gemacht. Der Rest ist Kernel Sache. Solaris ist ein Vertreter. Die User Level Threads müssen an die Kernel Prozess geheftet werden. Daher wurde eine weitere Schicht eingeführt, die sogenannten LWP (lightweigh process). Die User-Threads werden den LWPs zugeführt. Nur die Threads auf den LWPs sind aktiv. Dabei beinhaltet die LWPs die Kernel Level Threads, welche für die Kernel Level Tasks verwendet werden. Das OS verwendet schlussendlich wirklich nur die Kernel Level Threads. Systemcalls müssen nicht über die Kernel Threads erledigt werden, sondern werden direkt weitergeleitet.

\begin{figure}[h!]
\centering
\includegraphics[width=0.7\linewidth]{fig/system-software-aufbau-2-level-threading}
\caption{Aufbau Zwei Level Threading}
\label{fig:system-software-aufbau-2-level-threading}
\end{figure}

\subsection{Windows-Prozesse}
Prozesse existieren als Objekte. Werden als neue oder als Kopie bestehender Prozesse erzeugt. Kann pro Prozess auch mehrere Threads beinhalten. Sowohl Prozesse wie auch Threads haben eingebaute Synchronisierungs-Mechanismen.